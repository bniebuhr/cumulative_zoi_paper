---
title: "Appendix D"
subtitle: "Cumulative impacts of infrastructure on reindeer space use: fitting habitat selection models"
author: ""
date: ""
geometry: margin=2cm
abstract: |
  In this document we fit habitat selection models to wild reindeer GPS data to 
  assess if and how the impacts of multiple tourist infrastructure affect mountain reindeer 
  (*Rangifer tarandus*) habitat selection during summer. We describe the modeling 
  approach and present the results and predictions from the fitted models. This 
  document complements the description of materials and methods and the results
  presented in the main text of Niebuhr et al. *Estimating the cumulative impact 
  and zone of influence of anthropogenic features on biodiversity.*
# bibliography: cuminf_bib.bib
output:
  NinaR::jensAnalysis:
    highlight: tango
    fig_caption: yes
    toc: yes
header-includes:
  \usepackage{float}
  \usepackage{caption}
  \DeclareCaptionLabelFormat{Sformat}{#1 D#2}
  \captionsetup[figure]{labelformat=Sformat}
  \captionsetup[table]{labelformat=empty}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
# This is optional
# I choose the 'styler' package for tidying the code to preserve indentations
# I set the cutoff for code tidying to 60, but this doesn't currently work with styler.
# Set tidy = True to get the knitr default
# I want all figures as png and pdf in high quality in a subfolder called figure
library(NinaR)
library(kableExtra)

knitr::opts_chunk$set(
  echo = TRUE,
  tidy = "styler",
  dev = c("png", "pdf"),
  dpi = 600,
  fig.path = "figure/",
  fig.align="center",
  fig.pos = 'H',
  
  message=FALSE,
  warning=FALSE,
  options(scipen=999)
)

options(
  xtable.comment = F,
  xtable.include.rownames = F,
  nina.logo.y.pos = 0.15
)
palette(ninaPalette())

# captions
library(captioner)
caption <- captioner("Table D", FALSE)

# Connect to PostGIS
source("~/.pgpass")

##Or just use DBI::dbConnect
NinaR::postgreSQLConnect(
  host = "gisdata-db.nina.no",
  dbname = "gisdata",
  username = pg_username,
  password = pg_password,
  bigint  = "integer"
)

rm(list = c("pg_username", "pg_password"))
```

```{r load_packages, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
#Load packages
library(NinaR)

# data manipulation
library(dplyr)
library(purrr)
library(ggplot2) # for plot
library(ggpubr) # for plot
library(cowplot) # for plot

# spatial packages
library(rgrass7)
library(terra)
library(sf)
library(tmap)
require(RPostgres)
require(rpostgis)

# analysis
library(survival)

# oneimpact package
library(oneimpact)

# multifit
# devtools::install_github("phuais/multifitR", ref = "00486593698ce2b5432f7b566f839c70de56a52a")
library(multifitR)
```

# Introduction

In this document we describe the procedures to fit habitat selection
models to wild reindeer GPS data and assess if and how the impacts of
multiple infrastructure affect mountain reindeer (*Rangifer tarandus*)
habitat selection during summer. We first briefly describe the study area, the
GPS data handling, and the environmental variables used in the analysis.
We then describe the calculation of the infrastructure-related
covariates using both ZOI metrics, the cumulative zone of influence (ZOI) and 
the ZOI of the nearest feature. These metrics quantify the ZOI as well as how 
the influence varies with the distance to infrastructure. Then, we describe 
the structure of the statistical models and the fitting procedures and present 
the results in details.
We explore qualitatively the interpretation of both ZOI metrics
in single-infrastructure models, and then estimate the effect size 
and the ZOI of each infrastructure in multi-infrastructure models, 
to finally assess the combined impacts of infrastructure on reindeer 
habitat selection.

# Material and Methods

## Study area

```{r read_vectors, eval=TRUE, echo=FALSE, results="hide", message=FALSE, warning=FALSE}
# read vector files
vects <- list.files("../data/analysis_GPS/", pattern = "_v.shp|_v.gpkg", 
                    full.names = TRUE)

# norway
# no <- rnaturalearthdata::countries50[rnaturalearthdata::countries50$ADMIN == "Norway",] %>% 
#   sf::st_as_sf() %>% 
#   sf::st_transform(32633) %>% 
#   sf::st_cast(to = "POLYGON")
no <- rpostgis::pgListGeom(con, geog = TRUE) %>% 
  dplyr::filter(grepl("Fenoscandia_NUTS", table_name))
no <- rpostgis::pgGetGeom(con, c(no$schema_name, no$table_name), no$geom_column) %>% 
  sf::st_as_sf() %>% 
  dplyr::filter(grepl("NO", nuts_id)) %>% 
  sf::st_union()
# plot(no)

# study area and GPS points
study_area <- grep("study_area", vects, value = TRUE) %>% 
  sf::st_read()
use <- grep("use", vects, value = TRUE) %>% 
  sf::st_read()
# plot(terra::vect(study_area))
# plot(terra::vect(use), add = T)

# load infrastructure layers
infra_vars <- paste(c("private_cab", "pub_cab", "roads", "trails"), collapse = "|")
infra <- grep(infra_vars, vects, value = TRUE) %>% 
  purrr::map(.f = sf::st_read)

# count number of points
n_infra <- purrr::map_dbl(infra[1:3], nrow)
# count length of lines, in km
length_infra <- purrr::map_dbl(infra[4:6], ~ sum(st_length(.))/1e3)
```

The study area was the Hardangervidda wild reindeer area in Southern
Norway, where the largest remaining population of mountain reindeer is
found (Fig. D1). During summer, the area is mainly used for tourism.
Hardangervidda is a big plateau surrounded by large roads around its
contour, which corresponds to the lower part of the area (Fig. D2).
Towards the upper, central part, there are small access roads that link
the large highways to tourist resorts and a multitude of private
cabins, which are also connected by a network of trails (Fig. D2). The
area has `r n_infra[2]` large tourist resorts which are constantly
visited by many tourists and `r n_infra[3]` smaller public cabins. In
contrast, `r n_infra[1]` private cabins are spread throughout
Hardangervidda. Infrastructure data was retrieved from the N50 map,
obtained from GeoNorge map catalog (\url{https://kartkatalog.geonorge.no/}).

Due to their high density, most areas (90%) in Hardangervidda are closer
than 3 km from any private cabin and 5 km from the closest trail
(Table D1). In contrast, more than 50% of the areas are farther than 13
km from large tourist resorts and 10 km from small tourist cabins. There
are also many areas far from roads towards the central part of the
Hardangervidda (Table D1).

```{r plot_area1, eval=TRUE, echo=FALSE, results=FALSE, fig.show='hide'}
# plot
map_no <- tm_shape(no) +
  tm_borders() + 
  tm_shape(study_area) +
  tm_polygons(col = "brown2", border.col = "brown2") +
  tm_layout(title = "Norway",
            title.size = 1)
grob_no <- tmap_grob(map_no)

map_area <- tm_shape(study_area) +
  tm_borders() +
  tm_shape(use) +
  tm_dots(title = "Reindeer GPS data") +
  tm_scale_bar(text.size = 1.1) +
  tm_compass(position = c("right", "top"), text.size = 1.1)
grob_area <- tmap_grob(map_area)
```

```{r plot_area2, eval=TRUE, echo=FALSE, results='hide', fig.cap="Hardangervidda reindeer area in Southern Norway and reindeer GPS locations for the Summer season, used in this study."}
# plot
im <- ggdraw() +
  draw_plot(grob_area) +
  draw_plot(grob_no,
            width = 0.3, height = 0.3,
            x = 0.0, y = 0.97, vjust = 1)
im
```

## Reindeer GPS data

Between 2001 and 2019, 115 female reindeer were captured and monitored. 
Reindeer were immobilized from helicopter 
<!-- [see details in @evans_physiologic_2013]  -->
(see details in Evans et al., 2013) and equipped with GPS collars with drop-off
system. To regularize the fix rate among collars, we used 1 reindeer
position every 6 hours, summing up a total of 7478 positions for all individuals. 
We analyzed only the data from 1 July - 15 August, selected
here as a period representative of the summer, to avoid including
reindeer positions during either the end of the calving season or during
rut and autumn migration. For detailed data cleaning and preparation
procedures, see Panzacchi et al. (2015).
<!-- @panzacchi_searching_2015. -->

To perform habitat selection analyses, for each used GPS location we
created a set of 9 locations available but not used by reindeer, spread
randomly within this wild reindeer area (Fig. D1). The combination of
use and available locations was annotated with environmental
spatial data to assess the impacts of the different infrastructure on
reindeer space use.

```{r plot_infra, eval=TRUE, echo=FALSE, fig.cap="Main anthropogenic infrastructure in the Hardangervidda reindeer area, used to illustrate the landscape context. Only private cabins and large tourist resorts were included in the analysis."}
# plot
map1 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra[[1]]) +
  tm_dots(title = "Private cabins") +
  tm_scale_bar(position = c("RIGHT", "BOTTOM"), text.size = 0.6) +
  tm_compass(position = c("RIGHT", "TOP"), text.size = 0.6) +
  tm_layout(main.title = "Private cabins", main.title.size = 1)

map2 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra[[2]]) +
  tm_dots() +
  tm_layout(main.title = "Tourist resorts - large",
            main.title.size = 1)

map3 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra[[3]]) +
  tm_dots() +
  tm_layout(main.title = "Tourist cabins - small", 
            main.title.size = 1)

map4 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra[[4]]) +
  tm_lines() +
  tm_layout(main.title = "Roads - large",
            main.title.size = 1)

map5 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra[[5]]) +
  tm_lines() +
  tm_layout(main.title = "Roads - small",
            main.title.size = 1)

map6 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra[[6]]) +
  tm_lines() +
  tm_layout(main.title = "Trails",
            main.title.size = 1)

map_all <- tmap::tmap_arrange(map1, map2, map3, map4, map5, map6, ncol = 3)
map_all
```

```{r table_infra_dist, eval=TRUE, echo=FALSE}
r_l <- list.files("../data/analysis_GPS/", pattern = "euclidean",
                  full.names = TRUE)

infra_dist <- terra::rast(r_l)

# stats
vars_n <- c("Private cabins", "Large tourist resorts", "Small tourist cabins", 
            "Large roads", "Small roads", "Trails")
pr <- c(0, .1, 0.25, .5, .75, .9, 1)
nm <- c("Infrastructure", paste0(100*pr, "%"))
stats <- global(infra_dist, quantile, probs = pr, na.rm = T) %>% 
  tibble::as_tibble() %>% 
  tibble::add_column(infra = vars_n, .before = 1)
# stats

# show table
kableExtra::kbl(stats, booktabs = T, digits = 0, col.names = nm, caption = caption("Tab_1", "Quantiles of the Euclidean distance from each 100 m-side cell in the Hardangervidda reindeer area to the nearest feature (in meters), for the main anthropogenic infrastructure present in the study area.")) %>%
  kableExtra::kable_styling(latex_options = "HOLD_position", position = "center")
```

```{r plot_infra_dist, eval=FALSE, echo=FALSE, results='hide', fig.cap="Euclidean distance to the nearest feature of the main anthropogenic infrastructure in the Hardangervidda reindeer area."}
# plot
map1 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra_dist[[1]]+1) +
  tm_raster(title = "Distance (m)", style = "log10",
            legend.hist = FALSE) +
  tm_scale_bar(position = c("RIGHT", "BOTTOM"), text.size = 0.6) +
  tm_compass(position = c("RIGHT", "TOP"), text.size = 0.6) +
  tm_layout(main.title = "Private cabins", 
            main.title.size = 1,
            legend.position = c("LEFT", "BOTTOM"))

map2 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra_dist[[2]]+1) +
  tm_raster(title = "Distance (m)", style = "log10",
            legend.hist = FALSE) +
  tm_layout(main.title = "Tourist resorts - large", 
            main.title.size = 1,
            legend.position = c("LEFT", "BOTTOM"))

map3 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra_dist[[3]]+1) +
  tm_raster(title = "Distance (m)", style = "log10",
            legend.hist = FALSE) +
  tm_layout(main.title = "Tourist cabins - small", 
            main.title.size = 1,
            legend.position = c("LEFT", "BOTTOM"))

map4 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra_dist[[4]]+1) +
  tm_raster(title = "Distance (m)", style = "log10",
            legend.hist = FALSE) +
  tm_layout(main.title = "Roads - large", 
            main.title.size = 1,
            legend.position = c("LEFT", "BOTTOM"))

map5 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra_dist[[5]]+1) +
  tm_raster(title = "Distance (m)", style = "log10",
            legend.hist = FALSE) +
  tm_layout(main.title = "Roads - small", 
            main.title.size = 1,
            legend.position = c("LEFT", "BOTTOM"))

map6 <- tm_shape(study_area) +
  tm_borders() + 
  tm_shape(infra_dist[[6]]+1) +
  tm_raster(title = "Distance (m)", style = "log10",
            legend.hist = FALSE) +
  tm_layout(main.title = "Trails", 
            main.title.size = 1,
            legend.position = c("LEFT", "BOTTOM"))

map_all <- tmap::tmap_arrange(map1, map2, map3, map4, map5, map6, ncol = 3)
map_all
```

## Environmental covariates

The locations of most types of infrastructure in Hardangervidda are correlated.
Roads occur mostly in the lower parts of the area -- and are correlated
with elevation and terrain ruggedness -- while other infrastructure
occur closely together (e.g. small roads and cabins). For this reason,
and for illustration purposes, in the analyses presented here we
assessed only the impacts of private cabins and large tourist resorts.
The spatial data sources and details are described in
<!-- @panzacchi_searching_2015.  -->
Panzacchi et al. (2015).

First, the vector representation for each kind of
infrastructure was rasterized using a grid of 100 m resolution for an
extent which included a buffer of 50 km around the study area; 
the buffer was
used to avoid edge effects in the ZOI metrics' calculation. Then,
both the ZOI of the nearest feature and the cumulative ZOI
metrics were calculated. Since the infrastructure considered here
(cabins and resorts) are represented as points,
the input for influence calculation was the count
of features within each grid cell. Rasterization was made in GRASS
GIS (GRASS Development Team, 2017) using the `v.to.rast` module
and the `grass_v2rast_count` function from the `oneimpact` R package.
<!-- , while for the linear infrastructure -->
<!-- the input was a binary map (1 where infrastructure are located, 0 -->
<!-- elsewhere). -->

Influence measures were calculated considering ZOI function with different
shapes (threshold, linear, Gaussian, and exponential decays; see Appendix A), 
for a set of (irregularly distributed) radii, from 100 m to 20 km. 
This allowed us to assess whether
habitat selection is affected by either the cumulative impact or the
impact of the nearest feature, while estimating the ZOI radius and
accounting for the shape of the ZOI of the features of the
different types of infrastructure. All ZOI
functions were considered to have value 1 at the origin (where the
infrastructure are located) and vary according to the different shapes. 
For the threshold and linear decay
functions, the ZOI radius was defined as the distance at which the influence
decreases to zero. For the Gaussian and exponential decay functions,
which asymptotically approach zero, the ZOI radius was defined as the distance
at which the functions reach a limit value of 0.05 (see Appendix A).
The ZOI variables were computed with the `calc_zoi()` function of the 
`oneimpact` package using a R-GRASS GIS interface (with parameter 
$\verb|where = "GRASS"|$).
The different ZOI shapes and radii were computed by changing the parameters
`type` and `radius` in this function.

To account for bio-climatic and geographic variation in reindeer space use, we also
included as covariates land cover and 4 principal components (PCA axes)
from a large principal component analysis performed in Norway to
understand patterns of bio-climatic-geographical variation across the
country 
<!-- [@bakkestuen_step-less_2008].  -->
(Bakkestuen et al., 2008).
We used the SatVeg land cover map (Johansen, 2009)
with 30 m resolution and 25 vegetation classes, which we further grouped
for modeling purposes (see the final classes in Table D3). The four
bio-climatic principal components represent gradients of (1) PC1 - continentality,
(2) PC2 - altitude, (3) PC3 - terrain ruggedness, and (4) PC4 - solar
radiation, and account for 75 - 85% of the bio-climatic variation in
Norway, representing the major environmental gradients in the study area
<!-- [@panzacchi_searching_2015].  -->
(Panzacchi et al., 2015).
Prior to the analyses, the continuous
variables (all but land cover) were standardized to mean 0 and standard
deviation 1 using the `scale()` function in R.

```{r fit_models_unstructured, echo=FALSE, eval=FALSE}
# load data
load(file = "../data/analysis_GPS/cuminf_zoi_GPS_dataset_annotated.rda")
# names(dat)

# results table
# layers <- expand.grid(infrastructure = infrastructure,
#                             measure = measures,
#                             shape = shapes,
#                             zoi = zoi_vals)

# result table with covariate options
infrastructure = c("private_cabins", "public_cabins_high", "public_cabins_low", "roads_high", "roads_low", "trails")
measures <- c("cumulative", "nearest")
shapes <- c("threshold", "bartlett", "exp_decay") # add Gauss
zoi_vals <- c(100, 250, 500, 1000, 2500, 5000, 10000, 20000, 30000)

results <- expand.grid(private_cabin_measure = measures,
                       private_cabin_shape = shapes,
                       private_cabin_zoi = zoi_vals,
                       public_cabin_measure = measures,
                       public_cabin_shape = shapes,
                       public_cabin_zoi = zoi_vals)
# roads_high_measure = measures,
# roads_high_shape = shapes,
# roads_high_zoi = zoi_vals,
# roads_low_measure = measures,
# roads_low_shape = shapes,
# roads_low_zoi = zoi_vals,
# trails_measure = measures,
# trails_shape = shapes,
# trails_zoi = zoi_vals)

# re-organize
results <- results %>%
  tibble::tibble() %>%
  dplyr::mutate(pub_cab = "public_cabins",
                priv_cab = "private_cabins",
                mod = NA,
                AIC = NA)

head(results)
nrow(results)

# list of models
mods <- list()

# subset variables of interest
variables_interest1 <- c("use", "NORUTreclass")
variables_interest2 <- c("norway_pca")

# i=100
pb <- txtProgressBar(min = 0, max = nrow(results), style = 3)
for (i in 1:nrow(results)) {
  
  # dataset for analysis
  dat_analysis <- dat %>%
    dplyr::select(variables_interest1, starts_with(variables_interest2))
  
  # get parms
  parms <- results[i,]
  
  # get infrastructure variables
  
  # public cabins
  pub_cabins_name <- paste(parms$pub_cab, parms$public_cabin_measure,
                           parms$public_cabin_shape, parms$public_cabin_zoi, sep = "_")
  dat_analysis$public_cabins <- dat[, match(pub_cabins_name, names(dat))]
  
  # private cabins
  priv_cabins_name <- paste(parms$priv_cab, parms$private_cabin_measure,
                            parms$private_cabin_shape, parms$private_cabin_zoi, sep = "_")
  dat_analysis$private_cabins <- dat[, match(priv_cabins_name, names(dat))]
  
  #  mod <- rsf(use ~ ZOI_pub_cabins + ZOI_private_cabins + NORUTreclass + norway_pca_klima_axis1 + norway_pca_klima_axis2 + norway_pca_klima_axis3 + norway_pca_klima_axis4,
  #             m=0, B=0, data = dat)
  #  mod <- glm(use ~ ZOI_pub_cabins + ZOI_private_cabins + NORUTreclass + norway_pca_klima_axis1 + norway_pca_klima_axis2 + norway_pca_klima_axis3 + norway_pca_klima_axis4,
  #             data = dat, family=binomial)
  
  mod <- try(coxph(Surv(rep(1, length(use)), use) ~ scale(private_cabins) + scale(public_cabins) + NORUTreclass +
                     poly(scale(norway_pca_klima_axis1), 2) + poly(scale(norway_pca_klima_axis2),2) +
                     scale(norway_pca_klima_axis3) + scale(norway_pca_klima_axis4), data = dat_analysis))
  
  mods[[i]] <- mod
  results$AIC[i] <- try(AIC(mod))
  
  setTxtProgressBar(pb, i)
}

# save(results, mods, file = "../data/analysis_GPS/cuminf_zoi_results_rsf.rda")
```

## Habitat selection modeling

Reindeer habitat selection was modeled through habitat selection
functions (HSF, eq. 1 in the main text) considering the additive effect
of the covariates described above. We included a quadratic term for PC1
and PC2 to account for non-linear responses (Panzacchi et al., 2015).
<!-- [@panzacchi_searching_2015]. -->
HSFs were fitted through binomial generalized linear models using
the function `glm` in R (R Core Team, 2021, with parameter 
$\verb|family = binomial|$), 
with weight $w = 1$
for used locations and $w = 5000$ for available locations
(as suggested in Fieberg et al., 2021).
<!-- using the `coxph` function of the `survival` package -->
<!-- (Therneau, 2020; Therneau & Grambsch, 2000). -->
<!-- [@therneau_package_2020; @therneau_modeling_2000]. -->

The first step in the modeling approach was to fit HSFs considering one
infrastructure type at a time in a procedure of variable selection
(Burnham & Anderson, 2002),
<!-- [@burnham_model_2002],  -->
to infer which ZOI shape and radius better explained habitat selection, 
while also checking for
correlations among the predictors 
(an approach similar to Laforge et al., 2015, and Huais, 2018).
<!-- [an approach similar to -->
<!-- @laforge_process-focussed_2015 and @huais_multifit_2018].  -->
These models
included land cover and the bio-climatic PCAs, in addition to either the
cumulative ZOI or the ZOI of the nearest feature of a single
infrastructure type. Given that the ZOI metrics could assume 2
representations (cumulative, nearest) and follow 4 different shapes
(threshold, linear, Gaussian, exponential decay) with 8 distinct ZOI
radii (100 m, 250 m, 500 m, 1 km, 2.5 km, 5 km, 10 km, 20 km), for each
infrastructure type we fitted 64 HSFs. Additionally, we also fitted HSFs
considering the log-distance to the nearest feature, which is a
predictor commonly used in statistical models to assess the impacts of
anthropogenic infrastructure on biodiversity (e.g. Torres et al., 2016; 
Polfus et al., 2011). Single-infrastructure HSFs
were fit with the `multifit` function in R (Huais, 2018). HSFs were
compared though the Akaike information criterion (AIC), and for each
infrastructure type the 15 ZOI variables that better explained
habitat selection (lower AIC) were chosen to be included in the
multi-infrastructure HSF (see below).

<!-- We considered variables to be correlated if the Pearson correlation -->
<!-- coefficient between their values was higher than 0.6, and excluded those -->
<!-- variables with higher Variance Inflation Factor [VIF, which measures how -->
<!-- much the variance of an estimated regression coefficient is increased -->
<!-- because of collinearity @kutner_applied_2005]. -->
We considered variables to be correlated if the Pearson correlation
coefficient between their values was higher than 0.6, and excluded models
in which any of the infrastructure influence measures was correlated with 
the bio-climatic variables.

In the single-infrastructure HSFs, we also assessed the estimated
coefficients 
related to the infrastructure ZOI variables 
($\beta$'s in Eq. 2 of the main text). Even
though the coefficient values were not a criterion for selecting the
most parsimonious ZOI variables, they are important to indicate
consistency in the ZOI measures across the scales. If the
coefficient changes signs as
the ZOI radius increases, representing a shift from avoidance to selection, 
this might be a warning to be careful in the evaluation
of the most plausible ZOI. Since the continuous covariates were
standardized for model fitting, their model coefficients were 
rescaled back to the original covariate range, for interpretation
purposes and prediction.

We fitted multi-infrastructure HSFs by combining the best ZOI
variables for each infrastructure. Since not necessarily the best
ZOI shape and radius for single-infrastructure models will remain as
the most likely in multi-infrastructure models, we selected the 15 best
covariates for each infrastructure type and fitted all possible combinations
between them. For models in which the infrastructure covariates were 
correlated, we excluded those variables with higher Variance Inflation Factor 
(VIF, which measures how much the variance of an estimated 
regression coefficient is increased because of collinearity; Kutner, 2005).
<!-- @kutner_applied_2005].  -->
In total, we fitted
$15^2 = 225$ multi-infrastructure HSFs, which were also compared through AIC.

To quantify the impacts of infrastructure, for the most likely model 
we used eq. 3 of the main
text and multiplied the effect size -- the coefficients of
the fitted model -- by the ZOI variable included the model. We
then estimated habitat suitability by predicting the HSF (eq. 1 in the
main text) over the space and rescaling the predicted values to the
interval [0, 1].

```{r fit_models_univariate_glm, echo=FALSE, eval=FALSE, results='hide', fig.show='hide'}
# load data
load(file = "../data/analysis_GPS/cuminf_zoi_GPS_dataset_annotated.rda")
# names(dat)

#----
# standardize variables
vars_to_standardize <- c("private_cabins", "public_cabins_high", 
                         "public_cabins_low", "roads_high", "roads_low", "trails") %>% 
  paste(collapse = "|")

# cols to standardize
cols_std <- names(dat) %>% 
  grep(pattern = vars_to_standardize)

dat_sc <- dat %>% 
  dplyr::mutate(across(all_of(cols_std), scale),
                w = ifelse(use == 1, 1, 5000))

# check
head(dat$private_cabins_cumulative_threshold_10000)
head(dat_sc$private_cabins_cumulative_threshold_10000)

#----
# univariate model selection

# formula
form <- use ~ multief + NORUTreclass +
  poly(norway_pca_klima_axis1, 2) + poly(norway_pca_klima_axis2,2) +
  norway_pca_klima_axis3 + norway_pca_klima_axis4
# covariates
vars <- c("private_cabins", "public_cabins_high", "public_cabins_low", "roads_high", "roads_low", "trails")

# multiple fits
multifits <- multifitR::multifit_singlevar_multiple(mod = "glm", covariates = vars, 
                                                    data = dat_sc, 
                                                    args = c("family = binomial", "weights = w"),
                                                    formula = form, criterion = "AIC", 
                                                    corr_threshold = 0.6,
                                                    print_best = 15, 
                                                    print_sum = F, plot_est = F)

#---
# exploring some results

# 5 best models for each variable
multifits$model_comparison_all
# where are the log distance models?
log_models <- purrr::map_df(multifits$model_comparison, function(x) 
  x %>%
    tibble::rowid_to_column(var = "rank") %>%
    dplyr::filter(grepl("log", multief))) 
log_models
## 65 models in total
log_best <- log_models %>% 
  dplyr::filter(rank == min(rank))
log_best # best = 9 for priv cabins high

# correlations
corr <- purrr::map(multifits$model_elements, ~ .$corr) %>% 
  purrr::map(~ .[1:10])
corr_excluded <- purrr::map(corr, ~ purrr::map(.x, ~ .@excluded))
corr_matrix <- purrr::map2(corr, corr_excluded, ~ purrr::map2(.x, .y, function(x, y) 
  if(length(y) == 0) return(NULL) else return(x@corMatrix)))

corr_excluded

# errors?
err <- purrr::map(multifits$model_elements, ~ .$warnings) %>% 
  purrr::map(~ .[1:10])
err

# Check correlations between the variables - only 5 best scales
vars_corr <- multifits$model_comparison_all %>%
  dplyr::select(covariate, multief) %>% 
  tidyr::nest(multief) %>% 
  dplyr::mutate(vars_corr = purrr::map(data, ~ as.character(.$multief)))

corr_all_df <- expand.grid(private_cabins = vars_corr$vars_corr[[1]],
                           public_cabins_high =  vars_corr$vars_corr[[2]],
                           # public_cabins_low = vars_corr$vars_corr[[3]],
                           # roads_high = vars_corr$vars_corr[[4]],
                           # roads_low = vars_corr$vars_corr[[5]],
                           trails = vars_corr$vars_corr[[6]]) %>% 
  dplyr::mutate_all(as.character)

corr_all <- list()
corr_excluded <- list()
corr_kept <- list()
corr_th <- 0.6
for(i in 1:nrow(corr_all_df)) {
  # print(i)
  v <- corr_all_df[i,] %>% purrr:::flatten_chr()
  d <- dat_sc %>% dplyr::select(all_of(v))
  c <- usdm::vifstep(d, th = 2)
  corr_all[[i]] <- c
  corr_excluded[[i]] <- c@excluded
  corr_kept[[i]] <- c@results$Variables
}

v_ex <- unlist(corr_excluded)
table(v_ex)

# rescale model coefficients
rescaled_coefficients <- purrr::map(
  multifits$fits,
  function(x) {
    coefs_unsc_list <- purrr::map(x$models, ~ try(rescale_coefficients(., dat)[2]))
    coefs_unsc <- unlist(coefs_unsc_list)
    coefs_unsc[grep("Error", coefs_unsc)] <- NA
    coefs_unsc <- as.numeric(unname(coefs_unsc))
    coefs_unsc
  })

# model comparison table
model_comparison <- multifits$model_comparison
model_comparison_all <- multifits$model_comparison_all

save(rescaled_coefficients, model_comparison, model_comparison_all, file = "../data/analysis_GPS/cuminf_zoi_results_rsf_multifit_single_infra_glm.rda")
```

```{r fit_models_univariate_glm_checkAIC, echo=FALSE, eval=TRUE, results=FALSE, fig.show='hide'}
# load uni-variate models
load(file = "../data/analysis_GPS/cuminf_zoi_GPS_dataset_annotated.rda")
load("../data/analysis_GPS/cuminf_zoi_results_rsf_multifit_single_infra_glm.rda")

# best models
rescaled_coefficients
model_comparison$private_cabins
model_comparison$public_cabins_high
# model_comparison$trails
# 
# model_comparison$trails %>% 
#   dplyr::filter(grepl("nearest", multief)) %>% 
#   dplyr::select(-p.values) %>% 
#   dplyr::mutate(dAIC = dAIC - dAIC[1])

# rescale coefficients
# rescale_coefficients(multifits$fits[[1]]$models[[1]], dat)
# rescaled_coefficients <- purrr::map(
#   multifits$fits,
#   function(x) {
#     coefs_unsc_list <- purrr::map(x$models, ~ try(rescale_coefficients(., dat)[2]))
#     coefs_unsc <- unlist(coefs_unsc_list)
#     coefs_unsc[grep("Error", coefs_unsc)] <- NA
#     coefs_unsc <- as.numeric(unname(coefs_unsc))
#     coefs_unsc
#   })

# sd
sd_vals <- purrr::map(
  model_comparison,
  function(x) {
    sds <- purrr::map(
      x$multief, 
      function(y) {
        var_pred <- y#try(all.vars(y$formula)[2])
        if(grepl("Error", var_pred) | is.na(var_pred))
          return(NA)
        dat %>% 
          dplyr::pull(var_pred) %>% 
          sd(na.rm = TRUE)
      })
    unlist(sds)
  })

#---
# diagnostics
source("92_find_parms_cumulative.R")
diag_plots <- list()
diag_plots_zoom <- list()
diag_plots_zoom2 <- list()

for(i in 1:length(model_comparison)) {
  
  # extract parameters from variable name
  tab <- model_comparison[[i]] %>%
    dplyr::mutate(var = find_parms_cumulative(multief)$vars,
                  cum = find_parms_cumulative(multief)$cum,
                  shape = find_parms_cumulative(multief)$func,
                  zoi = find_parms_cumulative(multief)$zoi,
                  beta_unsc = rescaled_coefficients[[i]][rowid],
                  problems_fitting = ifelse(is.na(beta_unsc), "Fitting problems", "Fitting OK"),
                  AIC = ifelse(problems_fitting == "Fitting problems",
                               max(AIC, na.rm = T), AIC),
                  beta_unsc = ifelse(problems_fitting == "Fitting problems",
                                     0, beta_unsc))
  # get zoi (minimal AIC)
  tab_min <- tab %>% 
    dplyr::group_by(cum, shape) %>% 
    dplyr::summarise(rowid_min_aic = rowid[which.min(AIC)], 
                     zoi_min_aic = zoi[which.min(AIC)],
                     rowid_max_slope = rowid[which.max(abs(beta))],
                     zoi_max_slope = zoi[which.max(abs(beta))])
  
  # organize order
  tab$label <- as.factor(paste0(tab$cum, "_", tab$shape))
  tab$shape <- factor(tab$shape, 
                      levels = c("bartlett", "exp_decay", "Gauss", "threshold"),
                      labels = c("Linear decay", "Exponential decay",
                                 "Gaussian decay", "Threshold"))
  # remove log-distance for these plots
  tab <- dplyr::filter(tab, shape != "log")
  # ggdraw(p) + draw_label("XX", x = 0.02, y = 0.97)
  
  p1 <- tab %>% 
    ggplot(aes(rowid, AIC, color = shape)) +
    # geom_vline(xintercept = median(tab$rowid)-0.5, linetype = "dashed", col = "black") +
    geom_point(aes(shape = problems_fitting), show.legend = F) +
    # geom_point(aes(size = zoi)) +
    geom_line(show.legend = F) +
    facet_wrap(~label, labeller = labeller(label = function(x) ""), ncol = 10, scales = "free_x") +
    # annotate("text", x = median(tab$rowid)/2, y = min(tab$AIC, na.rm = T), label = "cumulative") + 
    # annotate("text", x = 3*median(tab$rowid)/2, y = min(tab$AIC, na.rm = T), label = "nearest") +
    labs(x = "ZOI radius with minimal AIC",#paste("ZOI for", gsub("_", " ", tab$var[1])),
         color = "Function") +
    scale_shape_manual(values=c(16, 8)) +
    scale_x_continuous(breaks = tab_min$rowid_min_aic, labels = tab_min$zoi_min_aic) +
    # theme(strip.background = element_blank(),
    #       strip.text.x = element_blank()) +
    theme_minimal() 
  p1 <- ggdraw(p1) +
    draw_label("Cumulative", x = 0.2, y = 0.95) +
    draw_label("Nearest", x = 0.6, y = 0.95)
  p1
  
  ssub <- seq(1, length(tab$rowid), 2)
  ttab <- tab %>% dplyr::arrange(rowid)
  p2 <- tab %>% 
    ggplot(aes(rowid, beta_unsc, color = shape, group = paste(cum, shape))) +
    # geom_vline(xintercept = median(tab$rowid)-0.5, linetype = "dashed", col = "black") +
    geom_point(aes(shape = problems_fitting)) +
    # geom_point(aes(size = zoi)) +
    geom_line() +
    facet_wrap(~label, labeller = labeller(label = function(x) ""), ncol = 10, scales = "free_x") +
    # annotate("text", x = median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "cumulative") + 
    # annotate("text", x = 3*median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "nearest") +
    labs(x = paste("ZOI radius for", gsub("_", " ", tab$var[1])),
         y = "Coefficient",
         color = "Function",
         shape = "Errors") +
    scale_shape_manual(values=c(16, 8)) +
    scale_x_continuous(breaks = ttab$rowid[ssub], labels = ttab$zoi[ssub]) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p2
  
  p2_zoom <- tab %>% 
    dplyr::mutate(beta_unsc = ifelse(abs(beta) > 20, NA, beta_unsc)) %>% 
    ggplot(aes(rowid, beta_unsc, color = shape, group = paste(cum, shape))) +
    # geom_vline(xintercept = median(tab$rowid)-0.5, linetype = "dashed", col = "black") +
    geom_point() +
    # geom_point(aes(size = zoi)) +
    geom_line() +
    facet_wrap(~label, labeller = labeller(label = function(x) ""), ncol = 10, scales = "free_x") +
    # annotate("text", x = median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "cumulative") + 
    # annotate("text", x = 3*median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "nearest") +
    labs(x = paste("ZOI radius for", gsub("_", " ", tab$var[1])),
         y = "Coefficient",
         color = "Function") +
    scale_x_continuous(breaks = ttab$rowid[ssub], labels = ttab$zoi[ssub]) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p2_zoom
  
  p12 <- ggpubr::ggarrange(p1, p2, nrow = 2, 
                           legend = "right", common.legend = T,
                           labels = "AUTO")
  p12
  
  p12_zoom <- ggpubr::ggarrange(p1, p2_zoom, nrow = 2, 
                                legend = "right", common.legend = T,
                                labels = "AUTO")
  p12_zoom
  
  p12_zoom2 <- ggpubr::ggarrange(p1, p2_zoom + ylim(-1, NA), nrow = 2, 
                                 legend = "right", common.legend = T,
                                 labels = "AUTO")
  p12_zoom2
  
  diag_plots[[i]] <- p12
  diag_plots_zoom[[i]] <- p12_zoom
  diag_plots_zoom2[[i]] <- p12_zoom2
}
```

```{r fit_models_univariate_glm_checkAIC_save, echo=FALSE, eval=FALSE, results=FALSE}
# save
for(i in 1:length(diag_plots)) {
  # save
  ggsave(paste0("glm_diag_plot_scale_univariate_", vars[i], ".png"), 
         plot = diag_plots[[i]], path = "output",
         width = 20, height = 20, units = "cm", dpi = 300)
  ggsave(paste0("glm_diag_plot_scale_univariate_", vars[i], "_zoom.png"), 
         plot = diag_plots_zoom[[i]], path = "output",
         width = 20, height = 20, units = "cm", dpi = 300)
  ggsave(paste0("glm_diag_plot_scale_univariate_", vars[i], "_zoom2.png"), 
         plot = diag_plots_zoom2[[i]], path = "output",
         width = 20, height = 20, units = "cm", dpi = 300)
  #print
  diag_plots[[i]]
}
```

```{r fit_models_univariate_coxph, echo=FALSE, eval=FALSE, results=FALSE, fig.show='hide'}
# load data
load(file = "../data/analysis_GPS/cuminf_zoi_GPS_dataset_annotated.rda")
# names(dat)

#----
# standardize variables
vars <- c("private_cabins", "public_cabins_high", "public_cabins_low", "roads_high", "roads_low", "trails")
vars_to_standardize <- vars %>% 
  paste(collapse = "|")

# cols to standardize
cols_std <- names(dat) %>% 
  grep(pattern = vars_to_standardize)

dat_sc <- dat %>% 
  dplyr::mutate(across(all_of(cols_std), scale)) #%>% 
# tidyr::drop_na(all_of(cols_std))

# check
head(dat$private_cabins_cumulative_threshold_10000)
head(dat_sc$private_cabins_cumulative_threshold_10000)

#----
# univariate model selection

# formula
form <- Surv(rep(1, length(use)), use) ~ multief + NORUTreclass +
  poly(norway_pca_klima_axis1, 2) + poly(norway_pca_klima_axis2,2) +
  norway_pca_klima_axis3 + norway_pca_klima_axis4
# covariates
# vars <- c("private_cabins", "public_cabins_high", "public_cabins_low", "roads_high", "roads_low", "trails")
# vars <- paste(vars, "nearest", sep = "_")

# multiple fits
multifits <- multifitR::multifit_singlevar_multiple(mod = "coxph", covariates = vars, 
                                                    data = dat_sc,
                                                    formula = form, criterion = "AIC", 
                                                    corr_threshold = 0.6,
                                                    print_best = 5, 
                                                    print_sum = F, plot_est = F)

#---
# exploring some results

# 5 best models for each variable
multifits$model_comparison_all
# where are the log distance models?
log_models <- purrr::map_df(multifits$model_comparison, function(x) 
  x %>%
    tibble::rowid_to_column(var = "rank") %>%
    dplyr::filter(grepl("log", multief))) 
log_models
## 65 models in total
log_best <- log_models %>% 
  dplyr::filter(rank == min(rank))
log_best # best = 10 for priv cabins high

# correlations
corr <- purrr::map(multifits$model_elements, ~ .$corr) %>% 
  purrr::map(~ .[1:5])
corr_excluded <- purrr::map(corr, ~ purrr::map(.x, ~ .@excluded))
corr_matrix <- purrr::map2(corr, corr_excluded, ~ purrr::map2(.x, .y, function(x, y) 
  if(length(y) == 0) return(NULL) else return(x@corMatrix)))

corr_excluded

# errors?
err <- purrr::map(multifits$model_elements, ~ .$warnings) %>% 
  purrr::map(~ .[1:5])
err

# Check correlations between the variables - only 5 best scales
vars_keep <- c("private_cabins", "public_cabins_high", "trails")

vars_corr <- multifits$model_comparison_all %>%
  dplyr::select(covariate, multief) %>% 
  tidyr::nest(multief) %>% 
  dplyr::mutate(vars_corr = purrr::map(data, ~ as.character(.$multief)))

corr_all_df <- expand.grid(private_cabins = vars_corr$vars_corr[[1]],
                           public_cabins_high =  vars_corr$vars_corr[[2]],
                           # public_cabins_low = vars_corr$vars_corr[[3]],
                           # roads_high = vars_corr$vars_corr[[4]],
                           # roads_low = vars_corr$vars_corr[[5]],
                           trails = vars_corr$vars_corr[[6]]) %>% 
  dplyr::mutate_all(as.character)

corr_all <- list()
corr_excluded <- list()
corr_kept <- list()
corr_th <- 0.6
for(i in 1:nrow(corr_all_df)) {
  # print(i)
  v <- corr_all_df[i,] %>% purrr:::flatten_chr()
  d <- dat_sc %>% dplyr::select(all_of(v))
  c <- usdm::vifstep(d, th = 2)
  corr_all[[i]] <- c
  corr_excluded[[i]] <- c@excluded
  corr_kept[[i]] <- c@results$Variables
}

v_ex <- unlist(corr_excluded)
table(v_ex)

save(multifits, file = "../data/analysis_GPS/cuminf_zoi_results_rsf_multifit_single_infra.rda")
```

```{r fit_models_univariate_coxph_checkAIC, echo=FALSE, eval=FALSE, results=FALSE, fig.show='hide'}
# load uni-variate models
load(file = "../data/analysis_GPS/cuminf_zoi_GPS_dataset_annotated.rda")
load("../data/analysis_GPS/cuminf_zoi_results_rsf_multifit_single_infra.rda")

# best models
multifits$model_comparison$private_cabins
multifits$model_comparison$public_cabins_high
# multifits$model_comparison$trails
# multifits$model_comparison$trails %>% 
#   dplyr::filter(grepl("nearest", multief)) %>% 
#   dplyr::select(-p.values) %>% 
#   dplyr::mutate(dAIC = dAIC - dAIC[1])

# rescale coefficients
rescaled_coefficients <- purrr::map(
  multifits$fits,
  function(x) {
    coefs_unsc_list <- purrr::map(x$models, ~ try(rescale_coefficients(., dat)[1]))
    coefs_unsc <- unlist(coefs_unsc_list)
    coefs_unsc[grep("Error", coefs_unsc)] <- NA
    coefs_unsc <- as.numeric(unname(coefs_unsc))
    coefs_unsc
  })

# sd
sd_vals <- purrr::map(
  multifits$model_comparison,
  function(x) {
    sds <- purrr::map(
      x$multief, 
      function(y) {
        var_pred <- y#try(all.vars(y$formula)[2])
        if(grepl("Error", var_pred) | is.na(var_pred))
          return(NA)
        dat %>% 
          dplyr::pull(var_pred) %>% 
          sd(na.rm = TRUE)
      })
    unlist(sds)
  })

#---
# diagnostics
source("92_find_parms_cumulative.R")
diag_plots <- list()
diag_plots_zoom <- list()
diag_plots_zoom2 <- list()

for(i in 1:length(multifits$model_comparison)) {
  
  # extract parameters from variable name
  tab <- multifits$model_comparison[[i]] %>%
    dplyr::mutate(var = find_parms_cumulative(multief)$vars,
                  cum = find_parms_cumulative(multief)$cum,
                  shape = find_parms_cumulative(multief)$func,
                  zoi = find_parms_cumulative(multief)$zoi,
                  beta_unsc = rescaled_coefficients[[i]][rowid],
                  problems_fitting = ifelse(is.na(beta_unsc), "Fitting problems", "Fitting OK"),
                  AIC = ifelse(problems_fitting == "Fitting problems",
                               max(AIC, na.rm = T), AIC),
                  beta_unsc = ifelse(problems_fitting == "Fitting problems",
                                     0, beta_unsc))
  # get zoi (minimal AIC)
  tab_min <- tab %>% 
    dplyr::group_by(cum, shape) %>% 
    dplyr::summarise(rowid_min_aic = rowid[which.min(AIC)], 
                     zoi_min_aic = zoi[which.min(AIC)],
                     rowid_max_slope = rowid[which.max(abs(beta))],
                     zoi_max_slope = zoi[which.max(abs(beta))])
  
  # organize order
  tab$label <- as.factor(paste0(tab$cum, "_", tab$shape))
  tab$shape <- factor(tab$shape, 
                      levels = c("bartlett", "exp_decay", "Gauss", "threshold"),
                      labels = c("Linear decay", "Exponential decay",
                                 "Gaussian decay", "Threshold"))
  # remove log-distance for these plots
  tab <- dplyr::filter(tab, shape != "log")
  # ggdraw(p) + draw_label("XX", x = 0.02, y = 0.97)
  
  p1 <- tab %>% 
    ggplot(aes(rowid, AIC, color = shape)) +
    # geom_vline(xintercept = median(tab$rowid)-0.5, linetype = "dashed", col = "black") +
    geom_point(aes(shape = problems_fitting), show.legend = F) +
    # geom_point(aes(size = zoi)) +
    geom_line(show.legend = F) +
    facet_wrap(~label, labeller = labeller(label = function(x) ""), ncol = 10, scales = "free_x") +
    # annotate("text", x = median(tab$rowid)/2, y = min(tab$AIC, na.rm = T), label = "cumulative") + 
    # annotate("text", x = 3*median(tab$rowid)/2, y = min(tab$AIC, na.rm = T), label = "nearest") +
    labs(x = "ZOI with minimal AIC",#paste("ZOI for", gsub("_", " ", tab$var[1])),
         color = "Function") +
    scale_shape_manual(values=c(16, 8)) +
    scale_x_continuous(breaks = tab_min$rowid_min_aic, labels = tab_min$zoi_min_aic) +
    # theme(strip.background = element_blank(),
    #       strip.text.x = element_blank()) +
    theme_minimal() 
  p1 <- ggdraw(p1) +
    draw_label("Cumulative", x = 0.2, y = 0.95) +
    draw_label("Nearest", x = 0.6, y = 0.95)
  p1
  
  ssub <- seq(1, length(tab$rowid), 2)
  ttab <- tab %>% dplyr::arrange(rowid)
  p2 <- tab %>% 
    ggplot(aes(rowid, beta_unsc, color = shape, group = paste(cum, shape))) +
    # geom_vline(xintercept = median(tab$rowid)-0.5, linetype = "dashed", col = "black") +
    geom_point(aes(shape = problems_fitting)) +
    # geom_point(aes(size = zoi)) +
    geom_line() +
    facet_wrap(~label, labeller = labeller(label = function(x) ""), ncol = 10, scales = "free_x") +
    # annotate("text", x = median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "cumulative") + 
    # annotate("text", x = 3*median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "nearest") +
    labs(x = paste("ZOI for", gsub("_", " ", tab$var[1])),
         y = "Coefficient",
         color = "Function",
         shape = "Errors") +
    scale_shape_manual(values=c(16, 8)) +
    scale_x_continuous(breaks = ttab$rowid[ssub], labels = ttab$zoi[ssub]) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p2
  
  p2_zoom <- tab %>% 
    dplyr::mutate(beta = ifelse(abs(beta) > 20, NA, beta)) %>% 
    ggplot(aes(rowid, beta, color = shape, group = paste(cum, shape))) +
    # geom_vline(xintercept = median(tab$rowid)-0.5, linetype = "dashed", col = "black") +
    geom_point() +
    # geom_point(aes(size = zoi)) +
    geom_line() +
    facet_wrap(~label, labeller = labeller(label = function(x) ""), ncol = 10, scales = "free_x") +
    # annotate("text", x = median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "cumulative") + 
    # annotate("text", x = 3*median(tab$rowid)/2, y = min(tab$beta, na.rm = T), label = "nearest") +
    labs(x = paste("ZOI for", gsub("_", " ", tab$var[1])),
         y = "Coefficient",
         color = "Function") +
    scale_x_continuous(breaks = ttab$rowid[ssub], labels = ttab$zoi[ssub]) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p2_zoom
  
  p12 <- ggpubr::ggarrange(p1, p2, nrow = 2, 
                           legend = "right", common.legend = T,
                           labels = "AUTO")
  p12
  
  p12_zoom <- ggpubr::ggarrange(p1, p2_zoom, nrow = 2, 
                                legend = "right", common.legend = T,
                                labels = "AUTO")
  p12_zoom
  
  p12_zoom2 <- ggpubr::ggarrange(p1, p2_zoom + ylim(-1, NA), nrow = 2, 
                                 legend = "right", common.legend = T,
                                 labels = "AUTO")
  p12_zoom2
  
  diag_plots[[i]] <- p12
  diag_plots_zoom[[i]] <- p12_zoom
  diag_plots_zoom2[[i]] <- p12_zoom2
}
```

```{r fit_models_univariate_coxph_checkAIC_save, echo=FALSE, eval=FALSE, results=FALSE}
# save
for(i in 1:length(diag_plots)) {
  # save
  ggsave(paste0("diag_plot_scale_univariate_", vars[i], ".png"), 
         plot = diag_plots[[i]], path = "output",
         width = 20, height = 20, units = "cm", dpi = 300)
  ggsave(paste0("diag_plot_scale_univariate_", vars[i], "_zoom.png"), 
         plot = diag_plots_zoom[[i]], path = "output",
         width = 20, height = 20, units = "cm", dpi = 300)
  ggsave(paste0("diag_plot_scale_univariate_", vars[i], "_zoom2.png"), 
         plot = diag_plots_zoom2[[i]], path = "output",
         width = 20, height = 20, units = "cm", dpi = 300)
  #print
  diag_plots[[i]]
}
```

# Results

## Single-infrastructure HSF

<!-- Small tourist cabins and roads were highly correlated with several of -->
<!-- the the bio-climatic PCAs, and large roads were correlated with PCA 2 -->
<!-- (elevational gradient), since most of them are found in the lower part -->
<!-- of the Hardangervidda plateau. For this reason, these three variables -->
<!-- were excluded from the analyses. -->

<!-- For the other three infrastructure types,  -->
We start by describing how
much support the different ZOI variables presented in explaining
reindeer habitat selection in the single-infrastructure models. By doing
so, we aim at showing qualitatively what the different influence
measures represent and how one would interpret them within an ecological
context.

### Private cabins

For private cabins, the most parsimonious HSF included the cumulative
ZOI with Gaussian decay shape and radius $r = 10$ km, but the support for the
cumulative ZOI with the same radius of 10 km but other shapes was
also relatively high (low relative difference in AIC, Fig. D3A).
Overall, the models including cumulative ZOI metrics (regardless
of the ZOI function shape and in great part of the ZOI radius) performed much
better than the ones including the ZOI of the nearest private
cabin (Fig. D3A), what points to strong evidence that the impacts of multiple
private cabins on reindeer habitat selection accumulate. The
coefficients were consistently negative across ZOI radii (Fig. D3B),
which indicates the ZOI radii with minimum AIC presented in the x axis
of the Fig. D3A are also consistent.

We also go beyond the simple statistical variable selection and
interpret the most parsimonious models considering the ZOI of the
nearest feature. In this case, regardless of the ZOI shape, the
ZOI radius varied from 500 m to 1000 m (Fig. D3A). Combining the results, we
can say that, if we consider the closest private cabin only, reindeer
generally avoid being closer than 1 km from any cabin, but since many
areas have a high density of cabins (Fig. D2, Table D1), they respond
to the combined impact of many individual cabins at a larger extent - a
zone of influence of 10 km radius. This might also be related to how the
cabins are used. Tourists who stay in a cabin hardly walk farther
than a few kilometers from it, since they must return to the cabin in
the end of the day. Then, the ZOI radius of a single cabin is shorter.
However, in areas where many private cabins are clustered, there is a
much wider area used by tourists and the radius of the ZOI of this combined 
cluster of cabins is higher.

```{r fit_models_univariate_glm_checkAIC_plot1, echo=FALSE, eval=TRUE, fig.cap="Model AIC (A) and coefficients (B) estimated for the zone of influence of private cabins in models including only this type of infrastructure. The plots show the AIC and the coefficients (scaled back to the original range of the covariates) of the cumulative ZOI and the ZOI of the nearest feature for different ZOI shapes and radii (see the x axis in B for some of the candidate ZOI radii values, in meters, which varied from 100 m to 20 km). The x axis in A shows the ZOI radius at which the AIC was minimal for each ZOI metric and shape. Scales marked with `*' represent errors in the model fitting (e.g. threshold ZOI of the nearest feature for ZOI = 10 km or 20 km, when the variable is constant = 1 over the whole study area)."}
diag_plots[[1]]
```

### Large tourist resorts

In the single-infrastructure models, there was also evidence of
cumulative impacts of large tourist resorts with a 20 km zone of
influence (Fig. D4). The most supported ZOI variable was the
cumulative ZOI with exponential decay shape and radius of 20 km. This
ZOI radius was selected regardless of the function shape, and even
for the ZOI of the nearest feature the most common radius was 20 km
(see the x axis in Fig. D4A).

The closer correspondence between the selected radius of cumulative
ZOI and nearest ZOI metrics, in comparison to the private
cabins, might be due to several factors. First, tourist resorts are
present at a much lower density in Hardangervidda, with high median 
distance to the closest resort (Fig. D2 and Table D1). As a
consequence, there is not so much difference between what the cumulative
and nearest ZOI metrics represent (as for the private
cabins), since the ZOI of each feature only start
to accumulate for larger radii. Therefore, 
the ZOI corresponding to smaller AIC is closer between models including 
cumulative and nearest metrics.
This is in accordance with the demonstrations
from Appendix C, where we showed that, for landscapes with sparse 
distribution of features and small ZOI radius, $\phi_{nearest}$ and $\phi_{cumulative}$
are highly correlated. 
Second, large tourist resorts are used very differently by tourists than
private cabins. Each resort is visited by a large load of tourists at a
time, which consequently use a much wider area around the resorts,
compared to each single private cabin. As a consequence, the ZOI radius of large
tourist resorts tend to be higher.

As for the private cabins, in the models with tourist resorts the coefficients were also
consistently negative, representing reindeer avoidance to public tourist resorts 
(Fig. D4B).

```{r fit_models_univariate_glm_checkAIC_plot2, echo=FALSE, eval=TRUE, fig.cap="Model AIC (A) and coefficients (B) estimated for the zone of influence of large tourist resorts in models including only this type of infrastructure. The plots show the AIC and the coefficients (scaled back to the original range of the covariates) of the cumulative ZOI and ZOI of the nearest feature for different ZOI shapes and radii (see the x axis in B for some of the candidate values for the radius, in meters, which varied from 100 m to 20 km). The x axis in A shows the ZOI radius at which the AIC was minimal for each ZOI metrics and shape."}
diag_plots_zoom[[2]]
```

```{r fit_models_univariate_glm_checkAIC_plot3, echo=FALSE, eval=FALSE, fig.cap="Model AIC (A) and coefficients (B) estimated for the zone of influence of tourist trails in models including only this type of infrastructure. The plots show the AIC and the coefficients (scaled back to the original range of the covariates) of the cumulative ZOI and ZOI of the nearest feature for different ZOI shapes and radii (see the x axis in B for some of the candidate values for the radius, in meters, which varied from 100 m to 20 km). The x axis in A shows the ZOI radius at which the AIC was minimal for each ZOI metrics and shape."}
diag_plots[[6]]
```

## Multi-infrastructure HSF

```{r fit_models_multivariate_coxph, echo=FALSE, eval=FALSE, results='hide', fig.show='hide'}
# univariate fits
form <- Surv(rep(1, length(use)), use) ~ multief + NORUTreclass +
  poly(norway_pca_klima_axis1, 2) + poly(norway_pca_klima_axis2,2) +
  norway_pca_klima_axis3 + norway_pca_klima_axis4
# covariates
vars_keep <- c("private_cabins", "public_cabins_high")#, "trails")
# fits
multifits <- multifitR::multifit_singlevar_multiple(mod = "coxph", covariates = vars_keep, 
                                                    data = dat_sc,
                                                    formula = form, criterion = "AIC", 
                                                    print_best = 10, 
                                                    print_sum = F, plot_est = F)
multifits$model_comparison_all

# univariate fits with only the nearest influence

# covariates
vars_nearest <- paste0(vars, "_nearest")
# fits
multifits_nearest <- multifitR::multifit_singlevar_multiple(mod = "coxph", covariates = vars_nearest,
                                                            data = dat_sc,
                                                            formula = form, criterion = "AIC",
                                                            print_best = 10,
                                                            print_sum = F, plot_est = F)
multifits_nearest$model_comparison_all
## It is expected that the selected scales will be very different! Because the range of influence goes from 0 to 1, not 0 to 300

# run multivariate models based on these scales
multiscale_fits <- multifitR::multifit_multivar(mod = "coxph",
                                                mod_comparison_df = multifits$model_comparison_all,
                                                data = dat_sc,
                                                formula = update(form, ~ . - multief),
                                                progress = T)
save(multiscale_fits, file = "../data/analysis_GPS/cuminf_zoi_results_rsf_priv_pub_cabins.rda")
# save(multiscale_fits, file = "../data/analysis_GPS/cuminf_zoi_results_rsf_priv_pub_cabins_trails.rda")
```

```{r fit_models_multivariate_glm, echo=FALSE, eval=FALSE, results='hide', fig.show='hide'}
# load data
load(file = "../data/analysis_GPS/cuminf_zoi_GPS_dataset_annotated.rda")
# names(dat)

#----
# standardize variables
vars_to_standardize <- c("private_cabins", "public_cabins_high", 
                         "public_cabins_low", "roads_high", "roads_low", "trails") %>% 
  paste(collapse = "|")

# cols to standardize
cols_std <- names(dat) %>% 
  grep(pattern = vars_to_standardize)

dat_sc <- dat %>% 
  dplyr::mutate(across(all_of(cols_std), scale),
                w = ifelse(use == 1, 1, 5000))

# check
head(dat$private_cabins_cumulative_threshold_10000)
head(dat_sc$private_cabins_cumulative_threshold_10000)

# formula
form <- use ~ multief + NORUTreclass +
  poly(norway_pca_klima_axis1, 2) + poly(norway_pca_klima_axis2,2) +
  norway_pca_klima_axis3 + norway_pca_klima_axis4
# # covariates
# vars_keep <- c("private_cabins", "public_cabins_high")#, "trails")
# # fits
# multifits <- multifitR::multifit_singlevar_multiple(mod = "glm", covariates = vars_keep,
#                                                     data = dat_sc,
#                                                     args = c("family = binomial", "weights = w"),
#                                                     formula = form, criterion = "AIC",
#                                                     corr_threshold = 0.6,
#                                                     print_best = 15,
#                                                     print_sum = F, plot_est = F)
# multifits$model_comparison_all
load(file = "../data/analysis_GPS/cuminf_zoi_results_rsf_multifit_single_infra_glm.rda")
vars_keep <- c("private_cabins", "public_cabins_high")
model_comparison_all <- model_comparison_all %>% 
  dplyr::filter(covariate %in% vars_keep)

# univariate fits with only the nearest influence

# covariates
# vars_nearest <- paste0(vars, "_nearest")
# # fits
# multifits <- multifitR::multifit_multivar(mod = "glm", covariates = vars_nearest,
#                                           data = dat_sc,
#                                           args = c("family = binomial", "weights = w"),
#                                           formula = form, criterion = "AIC",
#                                           corr_threshold = 0.6,
#                                           print_best = 15,
#                                           print_sum = F, plot_est = F)
# multifits_nearest$model_comparison_all
## It is expected that the selected scales will be very different! Because the range of influence goes from 0 to 1, not 0 to 300

# run multivariate models based on these scales
multiscale_fits <- multifitR::multifit_multivar(mod = "glm",
                                                mod_comparison_df = model_comparison_all,
                                                data = dat_sc,
                                                weights = dat_sc$w,
                                                # args = c("family = binomial", "weights = w"),
                                                args = c("family = binomial"),
                                                formula = update(form, ~ . - multief),
                                                verbose = FALSE,
                                                progress = TRUE)

str(multiscale_fits, max.level = 1)
multi_infra_model_comparison_df <- multiscale_fits$model_comparison_df
multi_infra_best_model_call <- multiscale_fits$best_model$call
save(multi_infra_best_model_call, multi_infra_model_comparison_df, file = "../data/analysis_GPS/cuminf_zoi_results_rsf_priv_pub_cabins_glm.rda")
# save(multiscale_fits, file = "../data/analysis_GPS/cuminf_zoi_results_rsf_priv_pub_cabins_trails.rda")
```

```{r check_results_glm, echo=FALSE, eval=TRUE, results='hide', fig.show='hide'}
load(file = "../data/analysis_GPS/cuminf_zoi_GPS_dataset_annotated.rda")
load(file = "../data/analysis_GPS/cuminf_zoi_results_rsf_priv_pub_cabins_glm.rda")

#----
# standardize variables
vars_to_standardize <- c("private_cabins", "public_cabins_high", 
                         "public_cabins_low", "roads_high", "roads_low", "trails") %>% 
  paste(collapse = "|")

# cols to standardize
cols_std <- names(dat) %>% 
  grep(pattern = vars_to_standardize)

dat_sc <- dat %>% 
  dplyr::mutate(across(all_of(cols_std), function(x) as.numeric(scale(x))),
                w = ifelse(use == 1, 1, 5000))

# check results
head(multi_infra_model_comparison_df)  
m1 <- eval(multi_infra_best_model_call)
# m1 <- models[[out_df$rowid[[2]]]]
# summary(m1)
# summary(m1)$rsq

# functions
# source("../../oneimpact/R/rescale_coefficients.R")
(coef_unsc <- rescale_coefficients(m1, dat))
cbind(coef(m1), coef_unsc)

#----
# output model selection table
var_to_name <- function(x, var_name, unit = "") {
  gsub(paste0(var_name, "_"), "", x) %>% 
    strsplit(split = "_") %>% 
    purrr::map_chr(function(y) {
      nn <- length(y)
      paste(y[1], paste(y[2:(nn-1)], collapse = " "), paste(as.numeric(y[nn])/1e3, unit, collapse = " "), sep = ", ")
    })
}

# var_to_name(out_df$private_cabins, "private_cabins")

moddf <- multi_infra_model_comparison_df %>%
  dplyr::select(-c(modelID, rank)) %>%
  tibble::rowid_to_column(var = "Rank") %>%
  dplyr::mutate(private_cabins = var_to_name(private_cabins, "private_cabins"),
                public_cabins_high = var_to_name(public_cabins_high, "public_cabins_high"),
                # roads_high = var_to_name(roads_high, "roads_high"),
                # roads_low = var_to_name(roads_low, "roads_low"),
                # trails = var_to_name(trails, "trails"),
                # private_cabin_shape = c("Threshold", "Linear", "Exponential")[private_cabin_shape],
                #             public_cabin_shape = c("Threshold", "Linear", "Exponential")[public_cabin_shape],
                AIC = round(AIC, 0),
                dAIC = round(dAIC, 1),
                k = length(m1$coefficients) + 1,
                wAIC = ifelse(wAIC < 0.001, "<0.001", round(wAIC, 3))) %>%
  # dplyr::select(-roads_low) %>% 
  dplyr::mutate_all(as.character)

# nearest influence models
first_nearest <- min(c(which(grepl("nearest", moddf$private_cabins)),
                       which(grepl("nearest", moddf$public_cabins_high))))
# which(grepl("nearest", moddf$roads_high)),
# which(grepl("nearest", moddf$trails))))
if(!(is.infinite(first_nearest)) & length(first_nearest) > 0)
  lines_to_keep <- c(1:5, first_nearest) else
    lines_to_keep <- c(1:5)

# log models
first_log <- min(c(which(grepl("log", moddf$private_cabins)),
                   which(grepl("log", moddf$public_cabins_high))))
# which(grepl("nearest", moddf$roads_high)),
# which(grepl("nearest", moddf$trails))))
if(!(is.infinite(first_log)) & length(first_log) > 0)
  lines_to_keep <- c(lines_to_keep, first_log)

moddf <- moddf %>%
  dplyr::slice(lines_to_keep) %>% 
  tibble::as_tibble() |> 
  dplyr::relocate(k, .before = "AIC")

names(moddf)[2] <- "Private cabins"
names(moddf)[3] <- "Large tourist cabins"
# names(moddf)[4] <- "Roads high"
# names(moddf)[5] <- "Trails"
xtable::xtable(moddf)
```

The most parsimonious multi-infrastructure model included the
cumulative ZOI of private cabins with threshold decay and $r = 10$ 
km and the cumulative ZOI of multiple tourist resorts with
exponential decay and $r = 20$ km ($\Delta AIC = 26.9$ from the 
second-ranked model, $wAIC = 1$; Table D2). Notice that, as
parameterized here, for the tourist resorts an exponential decay ZOI with radius
of 20 km means that the influence of resorts decrease to half of its
maximum value at ca. 5 km from the infrastructure
(exponential half life is \~ $ZOI/4$ here). The most plausible model with a
covariate for the ZOI of the nearest feature was ranked 26^th^ in
the model selection ($\Delta AIC = 921$), and the most likely model including the
log-distance to the nearest feature was ranked 44^th^ ($\Delta AIC = 1197$; 
Table D2). This presents strong support for the cumulative impacts of both 
private cabins and tourist resorts on reindeer habitat selection in
Hardangervidda.

```{r model_AIC_table, echo=FALSE, eval=TRUE}
kableExtra::kbl(moddf, booktabs = T, digits = 0, caption = caption("Tab_2", 'Infrastructure variables included in the most parsimonious models. Models ranked after the 5th place are omitted. For each model we show the type of ZOI metric (``cumulative", ``nearest"), the ZOI function (``exponential decay", ``gaussian decay", ``threshold", ``Bartlett or linear decay"), and the ZOI radius (in km) for that covariate included in the model. For each model we also present the number of parameters k, AIC, the difference in AIC to the most likely model (dAIC), and the AIC weight. The last lines show the most plausible model which included any variable with the ZOI of the nearest feature and the log-distance to the nearest feature (in this case, for tourist resorts). Models also included bio-climatic variables and land cover (see Table D3).')) %>%
  kableExtra::kable_styling(latex_options = "HOLD_position", position = "center")
```

Looking closely to the most plausible multi-infrastructure HSF (after
rescaling the coefficients back to the original range of variation of the infrastructure
ZOI predictors), we see both anthropogenic feature types are avoided by
reindeer. Their impact vary differently across space since their
ZOI functions and radii differ -- a threshold ZOI with 10 km
radius for private cabins and an exponential decay ZOI with 20 km radius for
tourist resorts --, but also because the estimated effect size of a single
private cabin ($\beta_{\text{private cabin}} = -0.0081$) was much smaller than
that of a single tourist resort ($\beta_{\text{tourist resort}} = -2.654$;
Table D3, Fig. D5A). However, since private cabins occur at much
higher densities, in some areas their overall impact is higher
than that of tourist resorts (Fig. D5, Fig. 4 in the main text). 
Comparing an area with only 1 cabin in a 10 km radius with an area with 
only 1 tourist resorts in a 
20 km radius, and assuming all other conditions are similar, the impact
-- measured here as the product between the effect size and
the ZOI covariate (eq. 5 from the main text) -- is much smaller
for private cabins (Fig. D5A). In contrast, if we take the areas with
higher influence in Hardangervidda -- where the number of private
cabins sum to 2664 and the (exponentially weighted) number of tourist
resorts sum to 5 -- the impact of private cabins agglomerates is higher 
than that of tourist resorts (Fig. D5C). Following
the HSF coefficient interpretation from Fieberg et al. (2021), and
considering that all other conditions are kept similar, 
a reindeer avoids an area 14.43 ($exp(330 \cdot 0.0081) = 14.43$) times 
more strongly than another area with
330 less private cabins in a radius of 10 km. That is approximately 
the same difference in avoidance a reindeer presents among two areas 
that differ in 1 tourist resort in a radius of 20 km 
($exp(1 \cdot 2.654) = 14.21$).

```{r check_results2_glm, echo=FALSE, eval=TRUE, results='hide', fig.show='hide'}
#----
# coefficients best model
m1

# ** output summary table #######
# moddf <- broom::tidy(m1) %>% 
#   dplyr::mutate(unscaled_estimate = c(round(coef_unsc[c(1,2)], 5), rep("", length(coef_unsc)-2))) %>% 
#   dplyr::relocate(unscaled_estimate, .after = estimate)
# moddf$estimate[c(1,2)] <- as.numeric(moddf$unscaled_estimate[c(1,2)])

moddf <- broom::tidy(m1) %>% 
  dplyr::mutate(unscaled_estimate = c(round(coef_unsc[c(1,2,3)], 5), rep("", length(coef_unsc)-3))) %>% 
  dplyr::relocate(unscaled_estimate, .after = estimate)
moddf$estimate[c(2,3)] <- as.numeric(moddf$unscaled_estimate[c(2,3)])
moddf <- moddf %>% dplyr::select(-unscaled_estimate)
# for(i in vars)
#   moddf$term[grepl(i, moddf$term)] <- paste0("scale(", gsub("_", " ", i), ")")
moddf$term[grepl("private_cabins", moddf$term)] <- "private cabins (cumulative, threshold, 10km)"
moddf$term[grepl("public_cabins", moddf$term)] <- "tourist resorts (cumulative, exponential, 20km)"
moddf$term[grepl("reclass12", moddf$term)] <- "exposed ridges"
moddf$term[grepl("reclass13", moddf$term)] <- "grass ridges"
moddf$term[grepl("reclass14", moddf$term)] <- "heather ridges"
moddf$term[grepl("reclass15", moddf$term)] <- "lichen"
moddf$term[grepl("reclass16", moddf$term)] <- "heather"
moddf$term[grepl("reclass17", moddf$term)] <- "heathland"
moddf$term[grepl("reclass18", moddf$term)] <- "meadows"
moddf$term[grepl("reclass19", moddf$term)] <- "early snowbed"
moddf$term[grepl("reclass20", moddf$term)] <- "late snowbed"
moddf$term <- gsub("norway_pca_klima_axis", "pc", moddf$term)
moddf$term <- gsub("NORUTreclass", "", moddf$term)
moddf <- moddf %>%
  dplyr::select(Covariate = term, Estimate = estimate, SE = std.error, p = p.value) %>%
  dplyr::mutate(Estimate = round(Estimate, 5),
                SE = round(SE, 2),
                p = ifelse(p < 0.0001, "< 0.0001", round(p, 4))) %>%
  dplyr::mutate_all(as.character)
moddf
xtable::xtable(moddf)
```

```{r model_coef_table, echo=FALSE, eval=TRUE}
kableExtra::kbl(moddf, booktabs = T, digits = 0, caption = caption("Tab_3", 'Effect size (model coefficients) of the most parsimonious model of space use for reindeer, including private cabins and tourist resorts. The table shows the coefficient estimates (scaled back to the scale of variation of the original data), their standard error (SE, in the standardized scale of the variables), and the significance (p). ``pc" are the bio-climatic principal components and ``poly" are the coefficients of a quadratic function of pc.')) %>%
  kableExtra::kable_styling(latex_options = "HOLD_position", position = "center")
```

```{r beta_and_zoi, echo=FALSE, eval=TRUE, results='hide', fig.show='hide'}
### 5. Plot impact ----
summary(m1)

# magnitude of the effect
# (coefs <- coef_unsc[1:2])
(coefs <- coef_unsc[2:3])

# take that from the models - function
infra <- c("Private cabins", "Large tourist resorts")
cum <- rep("cumulative", 2)
func <- c("threshold_decay", "exp_decay")
zoi_est <- c(10, 20)
points  <- 0

df_plots <- list()
for(i in 1:length(infra)) {
  df_plots[[i]] <- plot_zoi1d(points, zoi_est[i], zoi_metric = cum[i],
                              fun = func[i], 
                              range_plot = c(-20, 20), step = 0.1, 
                              return_df = TRUE)$zoi_df %>% 
    dplyr::mutate(infrastructure = infra[i],
                  measure = cum[i],
                  influence = func[i], 
                  zoi = zoi_est[i],
                  # multiply y per beta
                  y_displaced = y + (i-1),
                  impact = abs(as.numeric(coefs[i]))*y)
}
df_plots

# merge
df_plots <- dplyr::bind_rows(df_plots) %>% 
  dplyr::mutate(infrastructure = factor(infrastructure, levels = infra))

g1 <- df_plots %>% 
  ggplot(aes(x, y)) +
  geom_line() + 
  # inset_element(house, left = 0.01, right = 0.08, bottom = 0.02, top = 0.08) +
  facet_wrap(~infrastructure, ncol = 1) +
  labs(x = "Distance (km)", y = "Influence") +
  # scale_x_continuous(breaks = c(0, 3, 6, 9)) +
  theme_bw(base_size = 14)
g1

# ggsave("reindeer_zoi_influence.png", plot = g1, path = "../text/figures", 
#        width = 10, height = 10, units = "cm", dpi = 300)

g2 <- df_plots %>% 
  ggplot(aes(x, impact)) +
  # geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_line() + 
  # inset_element(house, left = 0.01, right = 0.08, bottom = 0.02, top = 0.08) +
  facet_wrap(~infrastructure, ncol = 1, scales = "free_y") +
  ylim(0, NA) +
  labs(x = "Distance (km)", y = "Impact") +
  # scale_x_continuous(breaks = c(0, 3, 6, 9)) +
  theme_bw(base_size = 14)
g2

# ggsave("reindeer_zoi_impact_unscaled_parms.png", plot = g2, path = "../text/figures", 
#        width = 10, height = 10, units = "cm", dpi = 300)

# range of values
df_plots
range_private_cabins <- c(1, quantile(dat$private_cabins_cumulative_threshold_10000, 
                                      probs = c(0.5, 1), na.rm = TRUE))
sd(dat$private_cabins_cumulative_threshold_10000, na.rm = T)
exp((coefs[1]*sd(dat$private_cabins_cumulative_threshold_10000, na.rm = T)))
exp((coefs[1]*300))
range_public_cabins_high <- c(1, quantile(dat$public_cabins_high_cumulative_exp_decay_20000, 
                                          probs = c(0.5, 1), na.rm = TRUE))
sd(dat$public_cabins_high_cumulative_exp_decay_20000, na.rm = T)
exp((coefs[2]*sd(dat$public_cabins_high_cumulative_exp_decay_20000, na.rm = T)))
exp((coefs[2]*1))

# plot minimum and maximum
df_plots_maxmin <- df_plots %>% 
  dplyr::mutate(impact_min = ifelse(infrastructure == "Private cabins", 
                                    impact*range_private_cabins[1],
                                    impact*range_public_cabins_high[1]),
                impact_median = ifelse(infrastructure == "Private cabins", 
                                       impact*range_private_cabins[2],
                                       impact*range_public_cabins_high[2]),
                impact_max = ifelse(infrastructure == "Private cabins", 
                                    impact*range_private_cabins[3],
                                    impact*range_public_cabins_high[3]))

# minimum
g3 <- g2 + facet_wrap(~infrastructure, ncol = 1) +
  labs(x = "", y = "") +
  ylim(0, 22)
g3

# median
g4 <- df_plots_maxmin %>% 
  ggplot(aes(x, impact_median)) +
  # geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_line() + 
  # inset_element(house, left = 0.01, right = 0.08, bottom = 0.02, top = 0.08) +
  facet_wrap(~infrastructure, ncol = 1) +#, scales = "free_y") +
  ylim(0, 22) +
  labs(x = "", y = "") +
  # scale_x_continuous(breaks = c(0, 3, 6, 9)) +
  theme_bw(base_size = 14)
g4

g5 <- df_plots_maxmin %>% 
  ggplot(aes(x, impact_max)) +
  # geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_line() + 
  # inset_element(house, left = 0.01, right = 0.08, bottom = 0.02, top = 0.08) +
  facet_wrap(~infrastructure, ncol = 1) +#, scales = "free_y") +
  ylim(0, 22) +
  labs(x = "", y = "") +
  # scale_x_continuous(breaks = c(0, 3, 6, 9)) +
  theme_bw(base_size = 14)
g5

g6 <- ggpubr::ggarrange(g3, g4, g5, labels = "AUTO", 
                        ncol = 3)

g7 <- ggpubr::ggarrange(g3, g5, labels = "AUTO", 
                        ncol = 2)

# Annotate the figure by adding a common labels
g6 <- annotate_figure(g6,
                      top = text_grob("   1-feature impact               Median impact                  Maximum impact", size = 14),
                      bottom = text_grob("Distance (km)", vjust = -1, size = 14),
                      left = text_grob("Impact", rot = 90, vjust = 2, size = 14))
g6

g7 <- annotate_figure(g7,
                      top = text_grob("      1-feature impact            Maximum impact", size = 14),
                      bottom = text_grob("Distance (km)", vjust = -1, size = 14),
                      left = text_grob("Impact", rot = 90, vjust = 2, size = 14))
g7

# ggsave("F4_reindeer_zoi_impact_single_multiple_features.png", plot = g7,
#        path = "../text/figures", width = 13, height = 10,
#        units = "cm", dpi = 300)
```

```{r beta_and_zoi_plot, echo=FALSE, eval=TRUE, fig.cap='Impact of private cabins and tourist resorts considering (A) only 1 feature, (B) the median number of features (103 for private cabins, 0.38 for tourist resorts), and (C) the maximum number of each type of feature (2664 for cabins, 5 for resorts), given their respective estimated ZOI shape and radius The impact presented here is the multiplication between the effect size (the model coefficients) and the cumulative ZOI variable (eq. 5 in the main text). The impact of only one private cabin is negligible (A). At their median values, the impacts of private cabins and public resorts are comparable (B), while at their maximum the cumulative impact of private cabins might be higher than that of tourist resorts (C).'}
g6
```

When cumulative impacts of infrastructure are predicted in space by multiplying
the effect size and the cumulative ZOI metrics, we
see how the relative impact of private cabins and large tourist resorts
change across space (see Fig. 5 in the main text). 
Since reindeer avoided high densities of both infrastructure types at
relatively large extents, areas of high habitat suitability for reindeer
corresponded to those in which the cumulative ZOI of both
infrastructure is low -- what matches with the locations used by
reindeer, indicated through the GPS data.

```{r retrieve_maps_from_grass, echo=FALSE, eval=FALSE}
### Retrieve maps from GRASS for prediction

# connect to GRASS
ms <- "u_bb_cuminf"
NinaR::grassConnect(mapset = ms)

# region
rgrass7::execGRASS("g.region", vector = "study_area", flags = c("a", "p"))
# mask
rgrass7::execGRASS("r.mask", vector = "study_area")

#-------
# vectors
study_area_g <- "study_area"
infra_g <- c("private_cabins@p_prodchange_envpoints",
             "pub_cabins_summer_high@p_prodchange_envpoints")

# study area
study_area_v <- rgrass7::read_VECT(study_area_g)
# cabins
priv_cab_within_g <- "private_cabins_within"
# rgrass7::execGRASS("v.select", ainput = infra_g[1], binput = study_area_g, 
#                    output = priv_cab_within_g, operator = "within")
private_cabins_v <- rgrass7::read_VECT(priv_cab_within_g)
pub_cab_high_within_g <- "public_cabins_high_within"
# rgrass7::execGRASS("v.select", ainput = infra_g[2], binput = study_area_g, 
#                    output = pub_cab_high_within_g, operator = "within")
public_cabins_high_v <- rgrass7::read_VECT(pub_cab_high_within_g)
# use
use_v <- dat %>% 
  dplyr::filter(use == 1) %>% 
  dplyr::select(x33, y33) %>% 
  as.matrix %>% 
  terra::vect(crs = crs(study_area_v))

# save vectors externally
vects <- c(study_area_v, private_cabins_v, public_cabins_high_v, use_v)
names_v <- c("study_area_v", "private_cabins_v", "public_cabins_high_v", "use_v")
for(i in 1:length(vects)) {
  v <- st_as_sf(vects[[i]])
  sf::st_write(v, paste0("../data/analysis_GPS/", names_v[i], ".gpkg"), delete_dsn = T)
  # terra::writeVector(vects[[i]],
  #                    filename = paste0("../data/analysis_GPS/", names_v[i], ".gpkg"),
  #                    overwrite = T)
}

# plot
# plot(use_v)

# plot(study_area_v)
# plot(public_cabins_high_v, add = T)
# 
# plot(study_area_v)
# plot(private_cabins_v, add = T)

#-------
# rasters

# model
m1

# list variables included in the model
m_vars <- all.vars(m1$formula)[-1]

# variables names in GRASS GIS
layers <- rgrass7::execGRASS("g.list", type = "raster", pattern = "*inf*", mapset = ms) %>%
  attr("resOut")
rgrass7::use_sp()
# find the layersof interest
priv_cab_g <- util_find_layer_GRASS(list("private_cabins", "cumulative", "threshold", "10000"),
                                    layers_grass = layers)
pub_cab_high_g <- util_find_layer_GRASS(list("public_cabins_high", "cumulative", "exp_decay", "20000"),
                                        layers_grass = layers)

# find the equivalent layers with influence of the nearest
priv_cab_near_g <- util_find_layer_GRASS(list("private_cabins", "nearest", "threshold", "10000"),
                                         layers_grass = layers)
pub_cab_high_near_g <- util_find_layer_GRASS(list("public_cabins_high", "nearest", "exp_decay", "20000"),
                                             layers_grass = layers)

m_vars_g <- c(priv_cab_g, pub_cab_high_g,
              "Vegetation_NORUT_2009",
              paste("Norway_PCA_klima_axis", 1:4, sep = ""))

# mapsets where variables are located
ms_cuminf <- "u_bb_cuminf"
ms_norut <- "g_LandCover_Norway_NORUT_vegetation"
ms_pca12 <- "g_BiogeographicalRegions_Norway_PCA_klima"
ms_pca34 <- "u_bram.van.moorter"

mapsets <- c(ms_cuminf, ms_cuminf, ms_norut, 
             ms_pca12, ms_pca12, 
             ms_pca34, ms_pca34)

raster_names <- paste(m_vars_g, mapsets, sep = "@")

# retrieve rasters
rasters <- rgrass7::read_RAST(raster_names[-3], return_format = "terra")
names(rasters) <- m_vars[-3]
lu_rast <- rgrass7::read_RAST(raster_names[3], NODATA = 255, return_format = "terra")
names(lu_rast) <- "norut"
raster_nearest <- rgrass7::read_RAST(c(priv_cab_near_g, pub_cab_high_near_g), return_format = "terra")
names(raster_nearest)

# remove mask from GRASS GIS
rgrass7::execGRASS("r.mask", flags = "r")

# stack and save rasters
all_rast <- c(rasters, lu_rast, raster_nearest)
paste(names(all_rast), collapse = "','")
terra::writeRaster(all_rast, "../data/analysis_GPS/rasters_to_predict_rsf.tif")
```

```{r predict_model_maps, echo=FALSE, eval=FALSE, fig.show='hide', results='hide'}
# model
m1

# coefficients
m_vars <- all.vars(m1$formula)[-1]
all_coefs <- coef(m1)

# load vectors
path <- "../data/analysis_GPS/"
study_area_v <- terra::vect(paste0(path, "study_area_v.gpkg"))
private_cabins_v <- terra::vect(paste0(path, "private_cabins_v.gpkg"))
public_cabins_high_v <- terra::vect(paste0(path, "public_cabins_high_v.gpkg"))
use_v <- terra::vect(paste0(path, "use_v.gpkg"))

# load raster
all_rast <- terra::rast("../data/analysis_GPS/rasters_to_predict_rsf.tif")
names(all_rast) <- c('private_cabins_cumulative_threshold_10000','public_cabins_high_cumulative_exp_decay_20000','norway_pca_klima_axis1','norway_pca_klima_axis2','norway_pca_klima_axis3','norway_pca_klima_axis4','NORUTreclass','private_cabins_inf_nearest_threshold10000','public_cabins_high_inf_nearest_exp_decay20000')
rasters <- all_rast[[1:6]]
lu_rast <- all_rast[[7]]
raster_nearest <- all_rast[[8:9]]

# prepare rasters for prediction
# scale continuous variables
rasters_scaled <- rasters
rasters_scaled[[1:2]] <- scale(rasters_scaled[[1:2]])
# terra::values(rasters_scaled[[1:2]]) <- scale(terra::values(rasters_scaled[[1:2]]))
# reclassify land cover raster
classes <- data.frame(id = sort(unique(values(lu_rast))),
                      NORUTreclass = as.character(sort(unique(values(lu_rast)))))
classes$NORUTreclass <- ifelse(classes$id < 9, "11forest",
                               ifelse(classes$id < 12, "bog",
                                      ifelse(classes$id < 21, "mountain",
                                             ifelse(classes$id < 22, "glacier",
                                                    ifelse(classes$id < 23, "water",
                                                           ifelse(classes$id < 25,"other", NA))))))
classes$NORUTreclass <- ifelse(classes$NORUTreclass == "mountain", as.character(classes$id), classes$NORUTreclass)
levels(lu_rast) <- as.data.frame(classes)
activeCat(lu_rast)
# check
# sort(unique(values(lu_rast)))
# levels(lu_rast)[[1]]
# sort(unique(dat$NORUTreclass))

# rasters for prediction
rast_df <- c(rasters_scaled, lu_rast)

# prediction on linear scale
pred <- predict(rast_df, m1)
# pred <- predict(m1, newdata = as.data.frame(rast_df))
# prediction on exp scale, rescaled
pred_sc <- oneimpact::raster_rescale(exp(pred))
# plot(pred_sc)

# prediction of impact of each variable
all_coefs
var_infra <- "private_cabins"
impact_priv <- -1*(all_coefs[grepl(var_infra, names(all_coefs))] *
                     rasters_scaled[[grepl(var_infra, names(rasters_scaled))]])
impact_priv_exp <- exp(-1*all_coefs[grepl(var_infra, names(all_coefs))] *
                         rasters_scaled[[grepl(var_infra, names(rasters_scaled))]])
impact_priv_exp_sc <- 1-raster_rescale(exp(all_coefs[grepl(var_infra, names(all_coefs))] *
                                             rasters_scaled[[grepl(var_infra, names(rasters_scaled))]]))
plot(impact_priv)
plot(private_cabins_v, add = TRUE)
plot(impact_priv_exp)
plot(private_cabins_v, add = TRUE)
plot(impact_priv_exp_sc)
plot(private_cabins_v, add = TRUE)

var_infra <- "public_cabins_high"
impact_pub <- -1*(all_coefs[grepl(var_infra, names(all_coefs))] *
                    rasters_scaled[[grepl(var_infra, names(rasters_scaled))]])
impact_pub_exp <- exp(-1*all_coefs[grepl(var_infra, names(all_coefs))] *
                        rasters_scaled[[grepl(var_infra, names(rasters_scaled))]])
impact_pub_exp_sc <- 1-raster_rescale(exp(all_coefs[grepl(var_infra, names(all_coefs))] *
                                            rasters_scaled[[grepl(var_infra, names(rasters_scaled))]]))
plot(impact_pub)
plot(public_cabins_high_v, add = TRUE)
plot(impact_pub_exp)
plot(public_cabins_high_v, add = TRUE)
plot(impact_pub_exp_sc)
plot(public_cabins_high_v, add = TRUE)

impact_sc <- raster_rescale(c(impact_priv, impact_pub), 
                            from = c(min(global(c(impact_priv, impact_pub), min, na.rm=T)$min), 
                                     max(global(c(impact_priv, impact_pub), max, na.rm=T)$max)))
plot(c(impact_priv, impact_pub))
plot(impact_sc, range = c(0,1))
```

```{r beta_and_zoi_maps_plot_int, echo=FALSE, eval=FALSE}
# plot 
library(tmap)

# sf objects
study_area_sf <- st_as_sf(study_area_v)
use_sf <- st_as_sf(use_v)

tmap_mode("view")
tm_basemap("OpenTopoMap") +
  tm_shape(raster_nearest$private_cabins_inf_nearest_threshold10000,
           name = "NearZOI Private cabins 10km") +
  tm_raster(style = "cont") +
  tm_shape(raster_nearest$public_cabins_high_inf_nearest_exp_decay20000,
           name = "NearZOI Public resorts high 20km") +
  tm_raster(style = "cont") +
  tm_shape(rasters$private_cabins_cumulative_threshold_10000,
           name = "CumZOI Private cabins 10km") +
  tm_raster(style = "log10") +
  tm_shape(rasters$public_cabins_high_cumulative_exp_decay_20000,
           name = "CumZOI Public resorts high 20km") +
  tm_raster(style = "cont") +
  tm_shape(impact_priv, name = "Impact Private cabins 10km") +
  tm_raster(style = "cont") +
  tm_shape(impact_pub, name = "Impact Public resorts 20km") +
  tm_raster(style = "cont") +
  tm_shape(pred_sc, 
           name = "Habitat suitability") +
  tm_raster() +
  tm_shape(study_area_sf,
           name = "Study area") +
  tm_borders() +
  tm_shape(use_sf, 
           name = "Reindeer use") +
  tm_dots() +
  tm_layout(title = "Reindeer GPS data")
```

```{r beta_and_zoi_maps_plot, echo=FALSE, eval=FALSE, results='hide', fig.show='hide'}
# plot 
library(tmap)
library(jcolors)

# sf objects
study_area_sf <- st_as_sf(study_area_v)
use_sf <- st_as_sf(use_v)
private_cabins_sf <- st_as_sf(private_cabins_v)
public_cabins_high_sf <- st_as_sf(public_cabins_high_v)

save <- TRUE
path <- "../text/extra_figs/"
tmap_mode("plot")

# GPS
p_gps <- tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  tm_shape(use_sf, name = "Reindeer use") +
  tm_dots() +
  tm_layout(main.title = "C) Reindeer GPS data",
            main.title.size = 1, legend.title.size = 1)
p_gps

# Private cabins
p_priv_cab <- tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  tm_shape(private_cabins_sf, name = "Private cabins") +
  tm_dots() +
  tm_layout(main.title = "Private cabins",
            main.title.size = 1, legend.title.size = 1)
p_priv_cab

# Tourist cabins
p_pub_cab <- tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  tm_shape(public_cabins_high_sf, name = "Tourist resorts") +
  tm_dots() +
  tm_layout(main.title = "Tourist resorts",
            main.title.size = 1, legend.title.size = 1)
p_pub_cab

# Private cabins cumulative influence
p_priv_cab_cuminf <- tm_shape(rasters[[1]]) +
  tm_raster(style = "log10", title = "# cabins") +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  tm_shape(private_cabins_sf, name = "Private cabins") +
  tm_dots() +
  tm_layout(main.title = "A) Cumulative zone of influence 10km - Private cabins", 
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_priv_cab_cuminf

# Tourist cabins cumulative influence
p_pub_cab_cuminf <- tm_shape(rasters[[2]]) +
  tm_raster(style = "cont", title = "# resorts") +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  tm_shape(public_cabins_high_sf, name = "Tourist cabins") +
  tm_dots() +
  tm_layout(main.title = "B) Cumulative zone of influence 20km - Tourist resorts",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_pub_cab_cuminf

# Private cabins nearest influence
p_priv_cab_nearinf <- tm_shape(raster_nearest[[1]]) +
  tm_raster(style = "cont", title = "Influence") +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  tm_shape(private_cabins_sf, name = "Private cabins") +
  tm_dots() +
  tm_layout(main.title = "Nearest zone of influence - Private cabins",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_priv_cab_nearinf

# Tourist cabins nearest influence
p_pub_cab_nearinf <- tm_shape(raster_nearest[[2]]) +
  tm_raster(style = "cont", title = "Influence") +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  tm_shape(public_cabins_high_sf, name = "Tourist cabins") +
  tm_dots() +
  tm_layout(main.title = "Nearest zone of influence - Tourist resorts",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_pub_cab_nearinf

# Private cabins impact
p_priv_cab_impact <- tm_shape(impact_priv) +
  tm_raster(style = "cont", title = "Impact", 
            palette = jcolors::jcolors("pal12"), midpoint = NA,
            breaks = seq(0, 18, by = 5)) +
  # palette = get_brewer_pal("Reds", n = 20)) +
  # palette = viridisLite::plasma(20, begin = 0.35, end = 1)) +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  # tm_shape(private_cabins_sf, name = "Private cabins") +
  # tm_dots() +
  tm_layout(main.title = "D) Impact - Private cabins",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_priv_cab_impact

# Private cabins impact scaled 
p_priv_cab_impact_sc <- tm_shape(impact_sc[[1]]) +
  tm_raster(style = "cont", title = "Impact", 
            palette = jcolors::jcolors("pal12"), midpoint = NA) +
  # palette = get_brewer_pal("Reds", n = 20)) +
  # palette = viridisLite::plasma(20, begin = 0.35, end = 1)) +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  # tm_shape(private_cabins_sf, name = "Private cabins") +
  # tm_dots() +
  tm_layout(main.title = "Impact - Private cabins",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_priv_cab_impact_sc

# Private cabins impact with exponential and scaled 
p_priv_cab_impact_exp_sc <- tm_shape(impact_priv_exp_sc) +
  tm_raster(style = "cont", title = "Impact", 
            palette = jcolors::jcolors("pal12"), midpoint = NA) +
  # palette = get_brewer_pal("Reds", n = 20)) +
  # palette = viridisLite::plasma(20, begin = 0.35, end = 1)) +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  # tm_shape(private_cabins_sf, name = "Private cabins") +
  # tm_dots() +
  tm_layout(main.title = "Impact - Private cabins",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_priv_cab_impact_exp_sc

# Tourist cabins impact
p_pub_cab_impact <- tm_shape(impact_pub) +
  tm_raster(style = "cont", title = "Impact", 
            palette = jcolors::jcolors("pal12"), midpoint = NA,
            breaks = seq(0, 18, by = 5)) +
  # palette = get_brewer_pal("Reds", n = 20)) +
  # palette = viridisLite::plasma(20, begin = 0.35, end = 1)) +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  # tm_shape(public_cabins_sf, name = "Tourist cabins") +
  # tm_dots() +
  tm_layout(main.title = "E) Impact - Tourist resorts",
            legend.frame = T, 
            main.title.size = 1, legend.title.size = 1)
p_pub_cab_impact

# Tourist cabins impact scaled 
p_pub_cab_impact_sc <- tm_shape(impact_sc[[2]]) +
  tm_raster(style = "cont", title = "Impact", 
            palette = jcolors::jcolors("pal12"), midpoint = NA, 
            breaks = seq(0, 1, 0.2)) +
  # palette = get_brewer_pal("Reds", n = 20)) +
  # palette = viridisLite::plasma(20, begin = 0.35, end = 1)) +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  # tm_shape(public_cabins_sf, name = "Tourist cabins") +
  # tm_dots() +
  tm_layout(main.title = "Impact - Tourist resorts",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_pub_cab_impact_sc

# Tourist cabins impact with exponential and scaled 
p_pub_cab_impact_exp_sc <- tm_shape(impact_pub_exp_sc) +
  tm_raster(style = "cont", title = "Impact", 
            palette = jcolors::jcolors("pal12"), midpoint = NA) +
  # palette = get_brewer_pal("Reds", n = 20)) +
  # palette = viridisLite::plasma(20, begin = 0.35, end = 1)) +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  # tm_shape(public_cabins_sf, name = "Tourist cabins") +
  # tm_dots() +
  tm_layout(main.title = "Impact - Tourist resorts",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_pub_cab_impact_exp_sc

# habitat suitability
p_suitability <- tm_shape(pred_sc) +
  tm_raster(style = "cont", title = "Suitability", 
            palette = jcolors::jcolors("pal11")) +
  # palette = get_brewer_pal("Reds", n = 20)) +
  # palette = viridisLite::plasma(20, begin = 0.35, end = 1)) +
  tm_shape(study_area_sf, name = "Study area") +
  tm_borders() +
  # tm_shape(use_sf, name = "GPS data") +
  # tm_dots() +
  tm_layout(main.title = "F) Habitat suitability",
            legend.frame = T,
            main.title.size = 1, legend.title.size = 1)
p_suitability

plots <- ls(pattern = paste("^p_p", "^p_suit", "^p_gps", sep = "|"))
if(save) {
  for(i in 1:length(plots)) {
    obj <- get(plots[i])
    f <- paste0(path, "reindeer_results_", plots[i], ".png")
    tmap_save(obj, filename = f, width = 15, height = 15, units = "cm", dpi = 300)
  }
}

# devtools::install_github("bniebuhr/bivarmap", ref = "HEAD")
# library(bivarmap)
# mat <- bivarmap_colmatrix(9, xlab = "Private cabins", ylab = "Tourist cabins", breakstyle = "")
# rast <- bivarmap_raster(impact_priv, impact_pub, mat)
# biv_plot <- bivarmap_map(rast, colmatrix = mat)
# biv_plot
# plot
```

<!-- \newpage -->

<!-- \blandscape -->

```{r beta_and_zoi_maps_plot2, echo=FALSE, eval=FALSE, results='hide', fig.cap='Maps of the most parsimonious cumulative zone of influence variables and their estimated impacts on reindeer habitat selection for private cabins and large tourist resorts. These maps are showed alongside the reindeer GPS locations in Hardengervidda and the estimated reindeer habitat suitability. Notice that the most suitable areas correspond to areas with low densities of both private cabins and tourist resorts.'}
maps_plot <- tmap::tmap_arrange(p_priv_cab_cuminf, p_pub_cab_cuminf, p_gps,
                                p_priv_cab_impact, p_pub_cab_impact, p_suitability,
                                ncol = 3, asp = 0)
maps_plot

tmap::tmap_save(maps_plot, filename = paste0(path, "F5_reindeer_results_prediction_maps.png"),
                width = 40, height = 20, units = "cm", dpi = 300)
```

<!-- \elandscape -->

<!-- \newpage -->

# References

Bakkestuen, V., Erikstad, L., & Halvorsen, R. (2008). Step-less models for regional environmental variation in Norway. Journal of Biogeography, 35(10), 1906–1922. https://doi.org/10.1111/j.1365-2699.2008.01941.x

Burnham, K. P., & Anderson, D. R. (2002). Model selection and multimodel inference: A practical information-theoretic approach (2nd ed). Springer.

Evans, A. L., Lian, M., das Neves, C. G., Os, Ø., Andersen, R., Aanes, R., Strand, O., Tryland, M., & Arnemo, J. M. (2013). Physiologic evaluation of medetomidine-ketamine anesthesia in free-ranging Svalbard (Rangifer tarandus platyrhynchus) and wild Norwegian Reindeer (Rangifer tarandus tarandus). Journal of Wildlife Diseases, 49(4), 1037–1041. https://doi.org/10.7589/2013-03-049

Fieberg, J., Signer, J., Smith, B., & Avgar, T. (2021). A ‘How to’ guide for interpreting parameters in habitat‐selection analyses. Journal of Animal Ecology, 90(5), 1027–1043. https://doi.org/10.1111/1365-2656.13441

GRASS Development Team. (2017). Geographic Resources Analysis Support System (GRASS GIS) Software, Version 7.8. Open Source Geospatial Foundation. http://grass.osgeo.org

Huais, P. Y. (2018). multifit: An R function for multi-scale analysis in landscape ecology. Landscape Ecology, 33(7), 1023–1028. https://doi.org/10.1007/s10980-018-0657-5

Johansen, B. E. (2009). Vegetasjonskart for Norge basert på LANDSAT TM/ETM+ data. (No. 4; p. 87). Northern Research Institute, NORUT.

Kutner, M. H. (Ed.). (2005). Applied linear statistical models (5th ed). McGraw-Hill Irwin.

Laforge, M. P., Vander Wal, E., Brook, R. K., Bayne, E. M., & McLoughlin, P. D. (2015). Process-focussed, multi-grain resource selection functions. Ecological Modelling, 305, 10–21.    
https://doi.org/10.1016/j.ecolmodel.2015.03.003

Panzacchi, M., Van Moorter, B., Strand, O., Loe, L. E., & Reimers, E. (2015). Searching for the fundamental niche using individual-based habitat selection modelling across populations. Ecography, 38(7), 659–669. https://doi.org/10.1111/ecog.01075

Polfus, J. L., Hebblewhite, M., & Heinemeyer, K. (2011). Identifying indirect habitat loss and avoidance of human infrastructure by northern mountain woodland caribou. Biological Conservation, 144(11), 2637–2646. https://doi.org/10.1016/j.biocon.2011.07.023

R Core Team (2021). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna,
Austria. URL https://www.R-project.org/.

Torres, A., Jaeger, J. A. G., & Alonso, J. C. (2016). Assessing large-scale wildlife responses to human infrastructure development. Proceedings of the National Academy of Sciences, 113(30), 8472–8477. https://doi.org/10.1073/pnas.1522488113


<!-- <div id="refs"></div> -->
